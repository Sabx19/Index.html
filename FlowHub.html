<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Salva l'Acqua - Gioco Minimal</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet" />
<style>
  /* Stili globali e sfondo */
  html, body {
    margin: 0; padding: 0; height: 100%;
    overflow: hidden; /* blocca scroll */
    /* Assicurati che questo URL sia corretto e accessibile */
    background: url('https://images.unsplash.com/photo-1547432326-78e709e13b48?q=80&w=1974&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D') no-repeat center center fixed;
    background-size: cover; /* Assicura che l'immagine copra tutto lo sfondo */
    font-family: 'Montserrat', sans-serif;
    -webkit-tap-highlight-color: transparent;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative; /* Per posizionare gli elementi assoluti */
  }

  /* Overlay per gli stati del gioco (menu, game over) */
  .game-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6); /* Sfondo scuro semitrasparente */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 20;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.4s ease-in-out, visibility 0.4s ease-in-out;
  }

  .game-overlay.active {
    opacity: 1;
    visibility: visible;
  }

  .overlay-content {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 20px;
    padding: 30px 40px;
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
    text-align: center;
    max-width: 90%;
    transform: scale(0.9);
    opacity: 0;
    transition: transform 0.4s ease-out, opacity 0.4s ease-out;
  }

  .game-overlay.active .overlay-content {
    transform: scale(1);
    opacity: 1;
  }

  .overlay-content h1 {
    color: #004d40;
    font-size: 3em;
    margin-bottom: 10px;
    text-shadow: 2px 2px 5px rgba(0,0,0,0.1);
  }

  .overlay-content p {
    color: #00796b;
    font-size: 1.2em;
    margin-bottom: 20px;
    line-height: 1.6;
  }

  /* Bottoni Generici */
  .button-primary {
    padding: 15px 40px;
    font-size: 1.4em;
    font-weight: 700;
    color: white;
    background: linear-gradient(45deg, #00796b, #004d40); /* Gradiente per il bottone */
    border: none;
    border-radius: 40px;
    box-shadow: 0 8px 15px rgba(0,121,107,0.5);
    cursor: pointer;
    user-select: none;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .button-primary:hover {
    background: linear-gradient(45deg, #004d40, #00796b);
    transform: translateY(-3px);
    box-shadow: 0 12px 20px rgba(0,121,107,0.7);
  }

  .button-primary:active {
    transform: translateY(0);
    box-shadow: 0 5px 10px rgba(0,121,107,0.4);
  }

  /* Punteggio */
  #score {
    position: fixed;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 24px;
    font-weight: 700;
    color: #004d40;
    text-shadow: 1px 1px 4px #b2dfdb;
    user-select: none;
    z-index: 10;
    background: rgba(255, 255, 255, 0.5);
    padding: 8px 15px;
    border-radius: 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  }

  /* Messaggi in-game (level up, ecc) */
  #message {
    position: fixed;
    top: 70px;
    left: 50%;
    transform: translateX(-50%);
    min-width: 280px;
    max-width: 80%;
    height: 50px;
    line-height: 50px;
    text-align: center;
    font-weight: 600;
    font-size: 20px;
    color: #00796b;
    background: #b2dfdbdd;
    border-radius: 25px;
    user-select: none;
    pointer-events: none;
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    z-index: 10;
    opacity: 0;
    transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    transform: translateX(-50%) translateY(-20px);
  }

  #message.active {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  /* Contenitore del gioco */
  #gameContainer {
    position: relative;
    width: 360px;
    height: 500px;
    background: transparent; /* RIMOSSO ANCHE QUI, NESSUNO SFONDO FISSO NEL CONTAINER */
    border-radius: 25px;
    box-shadow: 0 15px 30px rgba(0,0,0,0.2);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 5;
    border: 5px solid rgba(255, 255, 255, 0.5);
    overflow: hidden;
  }

  /* Canvas - Reso trasparente per far vedere lo sfondo sotto */
  canvas {
    background: transparent; /* MOLTO IMPORTANTE: DEVE ESSERE TRASPARENTE! */
    border-radius: 20px;
    box-shadow: none;
    touch-action: none;
    display: block;
    width: 340px;
    height: 440px;
  }

</style>
</head>
<body>

<div id="startMenu" class="game-overlay active">
  <div class="overlay-content">
    <h1>ðŸ’§ Salva l'Acqua ðŸ’§</h1>
    <p>Guida il contenitore per raccogliere le preziose gocce d'acqua ed evita che cadano a terra. Ogni livello aumenta la velocitÃ  e la sfida!</p>
    <button id="startButton" class="button-primary">Inizia a Giocare</button>
  </div>
</div>

<div id="gameOverScreen" class="game-overlay">
  <div class="overlay-content">
    <h1 id="gameOverTitle"></h1>
    <p id="gameOverMessage"></p>
    <p id="finalScore"></p>
    <button id="restartButton" class="button-primary">Riprova</button>
  </div>
</div>


<div id="score">Livello: 1 | Gocce raccolte: 0 / 5</div>
<div id="message"></div>
<div id="gameContainer">
Â  <canvas id="gameCanvas" width="340" height="440"></canvas>
</div>

<script>
Â  const canvas = document.getElementById('gameCanvas');
Â  const ctx = canvas.getContext('2d');
Â  const scoreDiv = document.getElementById('score');
Â  const messageDiv = document.getElementById('message');

Â  const startMenu = document.getElementById('startMenu');
Â  const startButton = document.getElementById('startButton');
Â  const gameOverScreen = document.getElementById('gameOverScreen');
Â  const gameOverTitle = document.getElementById('gameOverTitle');
Â  const gameOverMessage = document.getElementById('gameOverMessage');
Â  const finalScoreDiv = document.getElementById('finalScore');
Â  const restartButton = document.getElementById('restartButton');


Â  const bucket = {
Â Â Â  x: canvas.width / 2 - 60,
Â Â Â  y: canvas.height - 60,
Â Â Â  width: 120,
Â Â Â  height: 60,
    fillLevel: 0, // 0-1 per il riempimento
    shake: 0, // Per l'effetto di scuotimento
    shakeIntensity: 2 // IntensitÃ  dello scuotimento
Â  };

Â  let drops = [];
  const maxDrops = 15; // Limita il numero di gocce contemporaneamente sullo schermo

Â  const baseDropSpeed = 3;
Â  let dropSpeed = baseDropSpeed;

Â  let gameOver = true; // Inizia a true per mostrare il menu iniziale

Â  let level = 1;
Â  let dropsToCollect = 5;
Â  let dropsCollected = 0;

  // Variabili per il controllo dei suoni
  function createDripSound() {
      try {
          const ctxAudio = new (window.AudioContext || window.webkitAudioContext)();
          const osc = ctxAudio.createOscillator();
          const gainNode = ctxAudio.createGain();

          osc.type = 'triangle';
          osc.frequency.setValueAtTime(1000, ctxAudio.currentTime);
          gainNode.gain.setValueAtTime(0.1, ctxAudio.currentTime);

          osc.connect(gainNode);
          gainNode.connect(ctxAudio.destination);

          osc.start();

          osc.frequency.exponentialRampToValueAtTime(300, ctxAudio.currentTime + 0.2);
          gainNode.gain.exponentialRampToValueAtTime(0.001, ctxAudio.currentTime + 0.2);

          osc.stop(ctxAudio.currentTime + 0.2);
          osc.onended = () => ctxAudio.close();
      } catch (e) {
          console.warn("AudioContext non supportato o errore riproduzione drip:", e);
      }
  }

  function createGameOverSound() {
      try {
          const ctxAudio = new (window.AudioContext || window.webkitAudioContext)();
          const osc = ctxAudio.createOscillator();
          const gainNode = ctxAudio.createGain();

          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(150, ctxAudio.currentTime);
          gainNode.gain.setValueAtTime(0.2, ctxAudio.currentTime);

          osc.connect(gainNode);
          gainNode.connect(ctxAudio.destination);

          osc.start();
          osc.frequency.linearRampToValueAtTime(50, ctxAudio.currentTime + 0.8);
          gainNode.gain.exponentialRampToValueAtTime(0.001, ctxAudio.currentTime + 0.8);

          osc.stop(ctxAudio.currentTime + 0.8);
          osc.onended = () => ctxAudio.close();
      } catch (e) {
          console.warn("AudioContext non supportato o errore riproduzione game over:", e);
      }
  }

  function createLevelUpSound() {
      try {
          const ctxAudio = new (window.AudioContext || window.webkitAudioContext)();
          const osc = ctxAudio.createOscillator();
          const gainNode = ctxAudio.createGain();

          osc.type = 'sine';
          osc.frequency.setValueAtTime(440, ctxAudio.currentTime);
          gainNode.gain.setValueAtTime(0.15, ctxAudio.currentTime);

          osc.connect(gainNode);
          gainNode.connect(ctxAudio.destination);

          osc.start();
          osc.frequency.exponentialRampToValueAtTime(880, ctxAudio.currentTime + 0.15);
          gainNode.gain.exponentialRampToValueAtTime(0.001, ctxAudio.currentTime + 0.3);

          osc.stop(ctxAudio.currentTime + 0.3);
          osc.onended = () => ctxAudio.close();
      } catch (e) {
          console.warn("AudioContext non supportato o errore riproduzione level up:", e);
      }
  }


Â  function drawBackground() {
    // Non disegniamo uno sfondo opaco qui, il canvas Ã¨ trasparente.
    // L'immagine di sfondo del body Ã¨ ora visibile.
    // Manteniamo le onde se vuoi un effetto sopra lo sfondo del body
Â Â Â  ctx.strokeStyle = '#4db6ac33'; // Colore delle onde leggermente piÃ¹ visibile
Â Â Â  ctx.lineWidth = 2;
Â Â Â  for(let y = canvas.height - 50; y < canvas.height; y += 15){
Â Â Â Â Â  ctx.beginPath();
Â Â Â Â Â  for(let x = 0; x <= canvas.width; x += 15){
Â Â Â Â Â Â Â  const wave = 3 * Math.sin((x + y*2) * 0.12);
Â Â Â Â Â Â Â  ctx.lineTo(x, y + wave);
Â Â Â Â Â  }
Â Â Â Â Â  ctx.stroke();
Â Â Â  }
Â  }

Â  function drawBucket() {
    let currentBucketX = bucket.x + (Math.random() * bucket.shake * 2 - bucket.shake);
    const bucketTopY = bucket.y + 10;
    const bucketBottomY = bucket.y + bucket.height;
    const bucketInnerWidth = bucket.width * 0.8; // Base piÃ¹ stretta

    // Corpo del secchio (stile moderno, tipo "cisterna")
    ctx.beginPath();
    ctx.moveTo(currentBucketX + (bucket.width - bucketInnerWidth) / 2, bucketBottomY); // Base inferiore sinistra
    ctx.lineTo(currentBucketX + bucket.width - (bucket.width - bucketInnerWidth) / 2, bucketBottomY); // Base inferiore destra
    ctx.lineTo(currentBucketX + bucket.width, bucketTopY); // Lato superiore destro (piÃ¹ largo)
    ctx.lineTo(currentBucketX, bucketTopY); // Lato superiore sinistro (piÃ¹ largo)
    ctx.closePath();

    let bucketGradient = ctx.createLinearGradient(currentBucketX, bucketTopY, currentBucketX + bucket.width, bucketBottomY);
    bucketGradient.addColorStop(0, '#556270'); // Grigio scuro
    bucketGradient.addColorStop(0.5, '#7f8c8d'); // Grigio medio
    bucketGradient.addColorStop(1, '#556270'); // Grigio scuro
    ctx.fillStyle = bucketGradient;
    ctx.fill();

    // Bordo superiore metallico
    ctx.strokeStyle = '#34495e'; // Grigio molto scuro
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(currentBucketX, bucketTopY);
    ctx.lineTo(currentBucketX + bucket.width, bucketTopY);
    ctx.stroke();

    // Indicatore di riempimento (acqua interna)
    const waterHeight = bucket.fillLevel * (bucket.height - 20); // Altezza dell'acqua
    if (waterHeight > 0) {
        const waterY = bucketBottomY - waterHeight - 5; // Posizione Y dell'acqua
        // Larghezza dell'acqua, che varia con l'altezza
        const currentWaterWidth = bucketInnerWidth + (bucket.width - bucketInnerWidth) * (waterHeight / (bucket.height - 20));
        const waterX = currentBucketX + (bucket.width - currentWaterWidth) / 2;

        let waterFillGradient = ctx.createLinearGradient(waterX, waterY, waterX, bucketBottomY);
        waterFillGradient.addColorStop(0, 'rgba(102, 204, 255, 0.8)'); // Blu acqua chiaro
        waterFillGradient.addColorStop(1, 'rgba(0, 153, 204, 0.9)'); // Blu acqua scuro
        ctx.fillStyle = waterFillGradient;

        ctx.beginPath();
        // Disegna l'acqua come un trapezio che si adatta alla forma del secchio
        ctx.moveTo(waterX, bucketBottomY);
        ctx.lineTo(waterX + currentWaterWidth, bucketBottomY);
        ctx.lineTo(currentBucketX + bucket.width - (currentWaterWidth - bucketInnerWidth)/2, waterY);
        ctx.lineTo(currentBucketX + (currentWaterWidth - bucketInnerWidth)/2, waterY);
        ctx.closePath();
        ctx.fill();
    }

    // Riduzione progressiva dello scuotimento
    if (bucket.shake > 0) {
        bucket.shake = Math.max(0, bucket.shake - 0.5);
    }
Â  }

Â  function drawDrop(drop) {
    // Disegno della goccia come un diamante / cristallo
    const diamondSize = 8; // MetÃ  larghezza/altezza
    const diamondOffset = 2; // Offset per la punta inferiore

    ctx.beginPath();
    // Punto superiore
    ctx.moveTo(drop.x, drop.y - diamondSize);
    // Lato destro superiore
    ctx.lineTo(drop.x + diamondSize, drop.y);
    // Punto inferiore
    ctx.lineTo(drop.x, drop.y + diamondSize + diamondOffset);
    // Lato sinistro superiore
    ctx.lineTo(drop.x - diamondSize, drop.y);
    ctx.closePath();

    // Gradiente per l'effetto cristallo
    let gradient = ctx.createLinearGradient(drop.x - diamondSize, drop.y - diamondSize, drop.x + diamondSize, drop.y + diamondSize);
    gradient.addColorStop(0, 'rgba(173, 216, 230, 0.9)'); // Light blue (luce)
    gradient.addColorStop(0.3, 'rgba(135, 206, 250, 0.9)'); // Sky blue
    gradient.addColorStop(0.7, 'rgba(30, 144, 255, 0.9)'); // Dodger blue
    gradient.addColorStop(1, 'rgba(25, 25, 112, 0.9)'); // Midnight blue (ombra)
    ctx.fillStyle = gradient;
    ctx.fill();

    // Bordo sottile per definire la forma
    ctx.strokeStyle = 'rgba(0, 0, 100, 0.5)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Piccoli riflessi bianchi per brillantezza
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.beginPath();
    ctx.ellipse(drop.x - diamondSize * 0.4, drop.y - diamondSize * 0.4, diamondSize * 0.3, diamondSize * 0.2, -Math.PI / 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(drop.x + diamondSize * 0.2, drop.y - diamondSize * 0.7, diamondSize * 0.2, diamondSize * 0.1, Math.PI / 4, 0, Math.PI * 2);
    ctx.fill();
Â  }

Â  function spawnDrop() {
    if (drops.length >= maxDrops) {
        return;
    }
Â Â Â  const x = Math.random() * (canvas.width - 30) + 15;
Â Â Â  drops.push({ x: x, y: 0 });
Â  }

Â  function updateScore() {
Â Â Â  scoreDiv.textContent = `Livello: ${level} | Gocce raccolte: ${dropsCollected} / ${dropsToCollect}`;
Â  }

Â  function showMessage(text) {
Â Â Â  messageDiv.textContent = text;
Â Â Â  messageDiv.classList.add('active');
Â  }

Â  function hideMessage() {
Â Â Â  messageDiv.classList.remove('active');
Â  }

Â  function levelUp() {
Â Â Â  createLevelUpSound();
Â Â Â  level++;
Â Â Â  dropsCollected = 0;
Â Â Â  dropsToCollect += 3;
Â Â Â  dropSpeed = baseDropSpeed + (level - 1) * 0.5;
Â Â Â  showMessage(`ðŸŽ‰ Livello ${level} Raggiunto! VelocitÃ : ${dropSpeed.toFixed(1)} ðŸŽ‰`);
Â Â Â  updateScore();
Â Â Â  setTimeout(hideMessage, 2500);
Â  }

Â  function updateDrops() {
Â Â Â  for(let i = drops.length - 1; i >= 0; i--) {
Â Â Â Â Â  drops[i].y += dropSpeed;

Â Â Â Â Â  // Nuova logica di collisione per il secchio ridisegnato
Â Â Â Â Â  const bucketTopY = bucket.y + 10;
Â Â Â Â Â  const bucketBottomY = bucket.y + bucket.height;
Â Â Â Â Â  const bucketLeft = bucket.x;
Â Â Â Â Â  const bucketRight = bucket.x + bucket.width;
Â Â Â Â Â  // Approssimazione: controlla se la goccia Ã¨ all'interno della larghezza del secchio
Â Â Â Â Â  // e se la sua parte inferiore ha superato la parte superiore del secchio
Â Â Â Â Â  if (
Â Â Â Â Â Â Â  drops[i].x > bucketLeft &&
Â Â Â Â Â Â Â  drops[i].x < bucketRight &&
Â Â Â Â Â Â Â  drops[i].y + 8 > bucketTopY && // 8 Ã¨ circa la metÃ  inferiore della goccia diamante
Â Â Â Â Â Â Â  drops[i].y < bucketBottomY
Â Â Â Â Â  ) {
Â Â Â Â Â Â Â  drops.splice(i, 1);
Â Â Â Â Â Â Â  dropsCollected++;
Â Â Â Â Â Â Â  updateScore();
Â Â Â Â Â Â Â  createDripSound();
          // Aggiorna il livello di riempimento del secchio
          bucket.fillLevel = Math.min(1, dropsCollected / dropsToCollect);
          bucket.shake = bucket.shakeIntensity;

Â Â Â Â Â Â Â  if(dropsCollected >= dropsToCollect) {
Â Â Â Â Â Â Â Â Â  levelUp();
Â Â Â Â Â Â Â  }
Â Â Â Â Â  }
Â Â Â Â Â  else if(drops[i].y > canvas.height) {
Â Â Â Â Â Â Â  drops.splice(i, 1);
Â Â Â Â Â Â Â  endGame(false);
Â Â Â Â Â Â Â  return;
Â Â Â Â Â  }
Â Â Â  }
Â  }

Â  function draw() {
Â Â Â  ctx.clearRect(0, 0, canvas.width, canvas.height);
Â Â Â  drawBackground();
Â Â Â  drawBucket();
Â Â Â  drops.forEach(drawDrop);
Â Â Â  updateDrops();
Â  }

Â  function moveBucket(x) {
    let oldX = bucket.x;
Â Â Â  bucket.x = x - bucket.width / 2;
Â Â Â  if(bucket.x < 0) bucket.x = 0;
Â Â Â  if(bucket.x + bucket.width > canvas.width) bucket.x = canvas.width - bucket.width;
    if (Math.abs(bucket.x - oldX) > 5) {
        bucket.shake = bucket.shakeIntensity * 0.5;
    }
Â  }

Â  canvas.addEventListener('mousemove', e => {
Â Â Â  if(!gameOver) moveBucket(e.offsetX);
Â  });

Â  canvas.addEventListener('touchmove', e => {
Â Â Â  if(!gameOver) {
Â Â Â Â Â  e.preventDefault();
Â Â Â Â Â  const rect = canvas.getBoundingClientRect();
Â Â Â Â Â  let touch = e.touches[0];
Â Â Â Â Â  let x = touch.clientX - rect.left;
Â Â Â Â Â  moveBucket(x);
Â Â Â  }
Â  }, { passive: false });

Â  let dropInterval, gameLoop;

Â  function startGame() {
Â Â Â  startMenu.classList.remove('active');
    gameOverScreen.classList.remove('active');

Â Â Â  drops = [];
Â Â Â  bucket.x = canvas.width / 2 - 60;
    bucket.fillLevel = 0; // Resetta il riempimento del secchio
Â Â Â  level = 1;
Â Â Â  dropsToCollect = 5;
Â Â Â  dropsCollected = 0;
Â Â Â  dropSpeed = baseDropSpeed;
Â Â Â  gameOver = false;
Â Â Â  updateScore();
Â Â Â  showMessage(`ðŸš€ Benvenuto! Livello ${level}! VelocitÃ : ${dropSpeed.toFixed(1)} ðŸ’§`);
Â Â Â  setTimeout(hideMessage, 3000);

    clearInterval(dropInterval);
    clearInterval(gameLoop);

Â Â Â  dropInterval = setInterval(() => {
Â Â Â Â Â  if(!gameOver) spawnDrop();
Â Â Â  }, 700);

Â Â Â  gameLoop = setInterval(() => {
Â Â Â Â Â  if(!gameOver) draw();
Â Â Â  }, 1000/30);
Â  }

Â  function endGame(win) {
Â Â Â  gameOver = true;
Â Â Â  clearInterval(dropInterval);
Â Â Â  clearInterval(gameLoop);
    createGameOverSound();

Â Â Â  if(win) {
Â Â Â Â Â  gameOverTitle.textContent = 'ðŸŽ‰ Missione Compiuta! ðŸŽ‰';
Â Â Â Â Â  gameOverMessage.textContent = 'Hai salvato tutta l\'acqua!';
Â Â Â  } else {
Â Â Â Â Â  gameOverTitle.textContent = 'ðŸ’§ Ops! Acqua Sprecata! ðŸ’§';
Â Â Â Â Â  gameOverMessage.textContent = `Hai perso una goccia al Livello ${level}.`;
Â Â Â  }
    finalScoreDiv.textContent = `Gocce raccolte: ${dropsCollected} (Livello Finale: ${level})`;
Â Â Â  gameOverScreen.classList.add('active');
Â  }

Â  startButton.addEventListener('click', startGame);
Â  restartButton.addEventListener('click', startGame);

Â  window.addEventListener('touchmove', e => {
Â Â Â  e.preventDefault();
Â  }, { passive: false });

</script>

</body>
</html>
